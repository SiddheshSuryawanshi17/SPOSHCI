#!/usr/bin/env python3"""assembler_pass2.pyPass-II of a two-pass assembler (pseudo-machine) implemented in Python.Usage:    python3 assembler_pass2.py intermediate.txt symtab.txt littab.txtIf filenames are omitted, the script will prompt for them.Input: - intermediate.txt  : produced by Pass-I (LOC and source line per row) - symtab.txt        : symbol table (SYMBOL ADDRESS) one per line - littab.txt        : literal table (LITERAL ADDRESS) one per lineOutput: - object_code.txt   : machine-code-like output (LOC OPCODE REG ADDRESS/IMM) - listing printed to console"""import sysimport refrom typing import Dict, Tuple, Optional, Listclass SymbolTable:    def __init__(self):        self.table: Dict[str, int] = {}    def load_from_file(self, filename: str):        with open(filename, 'r') as f:            for line in f:                line = line.strip()                if not line:                    continue                parts = line.split()                # expect: SYMBOL ADDRESS                if len(parts) >= 2:                    name = parts[0]                    try:                        addr = int(parts[1])                    except ValueError:                        continue                    self.table[name] = addr    def get(self, symbol: str) -> Optional[int]:        return self.table.get(symbol)class LiteralTable:    def __init__(self):        self.table: Dict[str, int] = {}    def load_from_file(self, filename: str):        with open(filename, 'r') as f:            for line in f:                line = line.strip()                if not line:                    continue                parts = line.split()                # expect: LITERAL ADDRESS  (e.g. ='5' 101)                if len(parts) >= 2:                    lit = parts[0]                    try:                        addr = int(parts[1])                    except ValueError:                        continue                    self.table[lit] = addr    def get(self, literal: str) -> Optional[int]:        return self.table.get(literal)class PassIIAssembler:    # opcode and register mappings (adjust these to match your pseudo-machine)    OPCODE_MAP = {        "MOVER": 1, "MOVEM": 2, "ADD": 3, "SUB": 4,        "MULT": 5, "DIV": 6, "BC": 7, "COMP": 8,        "READ": 9, "PRINT": 10    }    REGISTER_MAP = {"AREG": 1, "BREG": 2, "CREG": 3, "DREG": 4}    literal_re = re.compile(r"^=('[^']'|-?\d+)$")  # ='A' or =5    def __init__(self, intermediate_file: str, symtab_file: str, littab_file: str):        self.intermediate_file = intermediate_file        self.symtab = SymbolTable()        self.littab = LiteralTable()        self.symtab.load_from_file(symtab_file)        self.littab.load_from_file(littab_file)        self.object_lines: List[Tuple[int, str]] = []    def is_literal(self, token: str) -> bool:        return bool(self.literal_re.match(token.strip()))    def is_register(self, token: str) -> bool:        return token.upper() in self.REGISTER_MAP    def parse_intermediate_line(self, line: str) -> Tuple[Optional[int], str]:        """        Parse a line from intermediate.txt produced by pass-I.        Returns (loc or None, rest_of_line_stripped)        intermediate.txt lines are assumed like: "100   LABEL OPCODE OPERANDS..."        or "      COMMENT..." (no loc)        """        # try to extract a leading integer (LOC)        # split by whitespace, if first token is integer -> that's the LOC        stripped = line.rstrip("\n")        parts = stripped.lstrip().split(None, 1)  # split into first token and rest        if not parts:            return None, ""        first = parts[0]        try:            loc = int(first)            rest = parts[1] if len(parts) > 1 else ""            return loc, rest.strip()        except ValueError:            # no loc            return None, stripped.strip()    def tokenize_source(self, src: str) -> Tuple[Optional[str], Optional[str], Optional[str]]:        """        Tokenize a source string into (label, opcode, operands).        Recognizes labels WITHOUT a trailing colon by checking the symbol table.        """        if not src:            return None, None, None        tokens = src.split()        if not tokens:            return None, None, None        label = None        opcode = None        operands = None        # If first token ends with ':' -> label with colon        if tokens[0].endswith(':'):            label = tokens[0][:-1]            tokens = tokens[1:]        elif tokens[0] in self.symtab.table:            # If the first token exists in symbol table, treat it as label (no colon)            label = tokens[0]            tokens = tokens[1:]        else:            # Heuristic fallback: if first token is not an opcode/directive/register/literal            # and there are at least two tokens, treat it as a label            first = tokens[0].upper()            if len(tokens) >= 2 and first not in self.OPCODE_MAP and first not in ("DC","DS","LTORG","END","START","ORIGIN","EQU"):                label = tokens[0]                tokens = tokens[1:]        if tokens:            opcode = tokens[0].upper()            if len(tokens) > 1:                operands = " ".join(tokens[1:])                operands = ",".join([x.strip() for x in operands.split(",")])        return label, opcode, operands    def resolve_operand_address(self, op: str) -> Tuple[int, Optional[int]]:        """        Resolve operand and return (reg_code, address_or_immediate)        reg_code = register number or 0        address_or_immediate = memory address for symbol/literal or immediate integer        """        if op is None or op == "":            return 0, None        op = op.strip()        # register first?        if self.is_register(op):            return self.REGISTER_MAP[op.upper()], None        # literal?        if self.is_literal(op):            addr = self.littab.get(op)            if addr is None:                raise ValueError(f"Literal {op} not found in literal table")            return 0, addr        # numeric immediate?        if re.fullmatch(r"-?\d+", op):            return 0, int(op)        # otherwise symbol        addr = self.symtab.get(op)        if addr is None:            raise ValueError(f"Symbol {op} not found in symbol table")        return 0, addr    def assemble(self):        """        Read intermediate file and produce object lines (LOC + machine code).        """        with open(self.intermediate_file, 'r') as f:            for raw in f:                loc, rest = self.parse_intermediate_line(raw)                if loc is None:                    # No LOC => comment/blank line, skip in object code                    continue                if not rest:                    continue                label, opcode, operands = self.tokenize_source(rest)                # directive handling that emit words:                if opcode == "DC":                    # DC operand is constant -> emit that constant as memory word                    # operands may be like "1" or "'A'"; try integer or char                    val = 0                    if operands:                        s = operands.strip()                        # handle character constant 'A'                        if (s.startswith("'") and s.endswith("'")) or (s.startswith('"') and s.endswith('"')):                            inner = s[1:-1]                            if len(inner) > 0:                                val = ord(inner[0])                        else:                            try:                                val = int(s)                            except ValueError:                                raise ValueError(f"Invalid DC operand '{s}' at LOC {loc}")                    self.object_lines.append((loc, f"DC    {val}"))                    continue                if opcode == "DS":                    # DS reserves words; output a marker or zero-initialized words.                    # We'll emit one line describing reservation.                    size = 1                    if operands:                        try:                            size = int(operands)                        except ValueError:                            raise ValueError(f"Invalid DS size '{operands}' at LOC {loc}")                    self.object_lines.append((loc, f"DS    {size}"))  # consumer (loader) can reserve                    continue                # LTORG/END/START/ORIGIN/EQU produce no object words                if opcode in ("LTORG", "END", "START", "ORIGIN", "EQU"):                    continue                # instruction (IS) -> produce machine word                if opcode in self.OPCODE_MAP:                    opc_num = self.OPCODE_MAP[opcode]                    # Default reg=0, addr=None                    reg_code = 0                    addr = None                    # operands can be empty, or "REG,SYMBOL" or "SYMBOL" or "REG,=5", etc.                    if operands:                        ops = [o.strip() for o in operands.split(",") if o.strip() != ""]                        # If two operands: first may be register, second mem/immediate                        if len(ops) == 1:                            # Could be register or symbol or literal                            if self.is_register(ops[0]):                                reg_code = self.REGISTER_MAP[ops[0].upper()]                            else:                                rc, a = self.resolve_operand_address(ops[0])                                if rc != 0:                                    reg_code = rc                                addr = a                        else:                            # take first as register if it's a register                            if self.is_register(ops[0]):                                reg_code = self.REGISTER_MAP[ops[0].upper()]                                # second operand is memory / literal / constant / symbol                                rc, a = self.resolve_operand_address(ops[1])                                if rc != 0:                                    # if second is register (rare), set reg_code and leave addr None                                    reg_code = rc                                addr = a                            else:                                # first not register => treat first as mem operand                                rc, a = self.resolve_operand_address(ops[0])                                if rc != 0:                                    reg_code = rc                                addr = a                                # if second exists and is register, use it                                if len(ops) > 1 and self.is_register(ops[1]):                                    reg_code = self.REGISTER_MAP[ops[1].upper()]                    # format object code: "opcode reg addr" where addr may be immediate/abs or blank                    addr_str = str(addr) if addr is not None else "0"                    self.object_lines.append((loc, f"{opc_num:02d}    {reg_code:01d}    {addr_str}"))                    continue                # Unknown opcode: mark as error / comment                self.object_lines.append((loc, f"??    {rest}"))    def write_object_file(self, outname="object_code.txt"):        with open(outname, 'w') as f:            for loc, code in self.object_lines:                f.write(f"{loc:<6} {code}\n")    def print_listing(self):        print("\nObject Code Listing:")        for loc, code in self.object_lines:            print(f"{loc:<6} {code}")        print("\nWrote object code to 'object_code.txt'\n")def main():    if len(sys.argv) >= 4:        interm = sys.argv[1]        symtab = sys.argv[2]        littab = sys.argv[3]    else:        interm = input("Intermediate filename (e.g. intermediate.txt): ").strip()        symtab = input("Symbol table filename (e.g. symtab.txt): ").strip()        littab = input("Literal table filename (e.g. littab.txt): ").strip()    assembler = PassIIAssembler(interm, symtab, littab)    try:        assembler.assemble()    except Exception as e:        print("Assembly error:", e)        return    assembler.write_object_file("object_code.txt")    assembler.print_listing()if __name__ == "__main__":    main()